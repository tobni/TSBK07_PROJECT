// simplefont.c, based on "font.c" from the OpenGL SDK by SGI
// Isolated to reusable code and extended by Ingemar 2009.
// New version, texture-based, OpenGL 3.2 compatible 2012.
// (No more glBitmap and no display lists.)

// This is a very simple, fixed-width bitmap font renderer.
// It is similar to the fonts in GLUT, but an isolated module,
// and a bit better! Nice new features: Placement relative to
// bottom or right (negative coordinates), smarter left edge clipping.
// font.c was CAPITAL LETTERS only, but here lower case is added, and numbers, and some more!
// It is still a simple, low-end text renderer. Try FTGL for a better one.

// Slightly modified 2013: Added "static" for internal variables and functions.
// This is important, reduces the risk of name collisions!

// Revised 2014: Multiple font support, can take image data from the host program
// (i.e. read from file) and create a new font given a few geometrical numbers
// from the host. Colorization is also supported (most suitable for white fonts).
// Fonts are supplied as images, must be monospaced.

// Note: I am doing my best to restore all settings that are changed but this
// isn't tested in a great variety of programs yet.

// By Ingemar Ragnemalm 2009-2014

#include "simplefont.h"

static GLubyte space[] = 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// Original CAPITAL letters
GLubyte letters[][13] = {
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18}, 
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e}, 
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3}, 
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff}
};

// Lower case
static GLubyte lowletters[][13] = {
{0x00, 0x00, 0x7d, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x7e, 0x00, 0x00, 0x00, 0x00}, // a
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0}, // b
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00}, // c
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03}, // d
{0x00, 0x00, 0x7e, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, // e
{0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0e}, // f
{0x7f, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, // g
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0}, // h
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00}, // i
{0x70, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00}, // j
{0x00, 0x00, 0xc3, 0xc7, 0xce, 0xfc, 0xfe, 0xc7, 0xc3, 0xc0, 0xc0, 0xc0, 0xc0}, // k
{0x00, 0x00, 0x0c, 0x1c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, // l
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00}, // m
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00}, // n
{0x00, 0x00, 0x7e, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, // o
{0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00}, // p
{0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00}, // q
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xf0, 0xdf, 0x00, 0x00, 0x00, 0x00}, // r
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00}, // s
{0x00, 0x00, 0x0e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x18}, // t
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, // u
{0x00, 0x00, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, // v
{0x00, 0x00, 0x66, 0x7e, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0x00, 0x00, 0x00, 0x00}, // w
{0x00, 0x00, 0xc3, 0xe7, 0x3c, 0x18, 0x3c, 0xe7, 0xc3, 0x00, 0x00, 0x00, 0x00}, // x
{0x7f, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, // y
{0x00, 0x00, 0xff, 0xc0, 0x70, 0x1c, 0x06, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00}, // z
};

// Numbers and more (same section of ASCII)
static GLubyte numletters[][13] = {
{0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c}, // 0
{0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18}, // 1
{0x00, 0x00, 0x7e, 0x60, 0x60, 0x60, 0x60, 0x3c, 0x06, 0x06, 0x66, 0x66, 0x3c}, // 2
{0x00, 0x00, 0x3c, 0x66, 0x06, 0x06, 0x06, 0x1c, 0x06, 0x06, 0x06, 0x66, 0x3c}, // 3
{0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x7f, 0x66, 0x36, 0x1e, 0x0e, 0x06}, // 4
{0x00, 0x00, 0x3c, 0x66, 0x06, 0x06, 0x06, 0x7c, 0x60, 0x60, 0x60, 0x60, 0x7e}, // 5
{0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x66, 0x3c}, // 6
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x1f, 0x06, 0x06, 0x06, 0x06, 0x7e}, // 7
{0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c}, // 8
{0x00, 0x00, 0x3c, 0x66, 0x06, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x3c}, // 9
{0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00}, // :
{0x00, 0x00, 0x30, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00}, // ;
{0x00, 0x00, 0x06, 0x1c, 0x30, 0x60, 0x30, 0x1c, 0x06, 0x00, 0x00, 0x00, 0x00}, // <
{0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00}, // =
{0x00, 0x00, 0x60, 0x38, 0x0c, 0x06, 0x0c, 0x38, 0x60, 0x00, 0x00, 0x00, 0x00}, // >
{0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x0c, 0x06, 0x06, 0x66, 0x3c}, // ?
};

static GLubyte specialletters[][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space
{0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, // !
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x00, 0x00}, // "
{0x00, 0x00, 0x24, 0x24, 0x7e, 0x7e, 0x24, 0x7e, 0x7e, 0x24, 0x24, 0x00, 0x00}, // #
{0x00, 0x00, 0x18, 0x3c, 0x5a, 0x5a, 0x1a, 0x3c, 0x58, 0x58, 0x5a, 0x3c, 0x18}, // $
{0x00, 0x00, 0x44, 0x4a, 0x6a, 0x24, 0x30, 0x18, 0x0c, 0x24, 0x56, 0x52, 0x22}, // %

{0x00, 0x00, 0x79, 0xcf, 0xc6, 0xcf, 0x79, 0x70, 0x78, 0xcc, 0xcc, 0xcc, 0x78}, // &
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x18, 0x00, 0x00}, // '
{0x00, 0x00, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x18, 0x0c}, // (
{0x00, 0x00, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x18, 0x30}, // )
{0x00, 0x00, 0x00, 0x00, 0x10, 0x54, 0x38, 0x54, 0x10, 0x00, 0x00, 0x00, 0x00}, // *
{0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00}, // +
{0x00, 0x30, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // ,
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // -
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // .
{0x00, 0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06}, // /
};

//static GLuint fontOffset;

static int gRasterH = 800;
static int gRasterV = 600;

/*
static int gCharacterHeight = 13;
static float gCharacterWidth = 8;
static float gTexHeight = 128;
static int gTexWidth = 128;
static int gExtraSpace = 0;
*/

static int gNumFonts = 0;
static int gCurFont = 0;

typedef struct SimpleFontData
{
	float characterHeight;
	float characterWidth;
	int texHeight;
	int texWidth;
	int extraSpace;
	GLuint textureID;
	float fontColorRed, fontColorGreen, fontColorBlue;

} SimpleFontData, *SimpleFontDataPtr;

SimpleFontData *fonts = NULL;


static int allocFont()
{
	gNumFonts += 1;
	void *p = malloc(sizeof(SimpleFontData) * gNumFonts);
	memcpy(p, fonts, sizeof(SimpleFontData) * (gNumFonts-1));
	if (fonts != NULL)
		free(fonts);
	fonts = p;
	gCurFont = gNumFonts-1;
	return gNumFonts-1;
}

void sfSetRasterSize(int h, int v)
{
	gRasterH = h;
	gRasterV = v;
}


// Inline shaders
static char frag[] =
"#version 150\n"
"out vec4 outColor;"
"in vec2 texCoord;"
"uniform sampler2D tex;"
"uniform float red,green,blue;"
"void main(void)"
"{"
"	outColor = texture(tex, texCoord) * vec4(red, green, blue, 1.0);"
//"	outColor = vec4(1.0);"
"}";

static char vert[]=
"#version 150\n"
"in  vec3 inPosition;"
"out vec2 texCoord;"
"uniform int x, y, c;"
"uniform int screenSizeX, screenSizeY;"
"uniform float charWidth, charHeight;"
"uniform int texWidth, texHeight;"
"void main(void)"
"{"
"	int row = c / 16;" // the character (c) gives row and column in the texture
"	int col = c & 15;"
//"	texCoord = vec2(inPosition.x/charWidth, inPosition.y/charHeight);"
//"	texCoord = vec2((col + inPosition.x/charWidth)/16.0, (row + (1.0 - inPosition.y/charHeight))*charHeight/texWidth);"
"	texCoord = vec2((col + inPosition.x)*charWidth/texWidth, (row + (1.0 - inPosition.y))*charHeight/texWidth);"
"	texCoord = vec2((col + inPosition.x)*charWidth/texWidth, (row + (inPosition.y))*charHeight/texWidth);"
""
"	float screenx = (x + inPosition.x*charWidth)*2.0/screenSizeX - 1.0;" // screen coords x and y
"	float screeny = -(y + inPosition.y*charHeight)*2.0/screenSizeY + 1.0;"
"	gl_Position = vec4(screenx, screeny, 0.0, 1.0);"
"}";

// Compile a shader, return reference to it
// No error checking - the shaders should be stable
static GLuint sfCompileShaders(const char *vs, const char *fs)
{
	GLuint v,f,p;

	v = glCreateShader(GL_VERTEX_SHADER);
	f = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(v, 1, &vs, NULL);
	glShaderSource(f, 1, &fs, NULL);
	glCompileShader(v);
	glCompileShader(f);
	p = glCreateProgram();
	glAttachShader(p,v);
	glAttachShader(p,f);
	glLinkProgram(p);
	glUseProgram(p);
	return p;
}


static GLfloat verticesOLD[] = {	0.0f,0.0f,0.0f,
								0.0f,13.0f,0.0f,
								8.0f,0.0f,0.0f,
								
								0.0f,13.0f,0.0f,
								8.0f,13.0f,0.0f,
								8.0f,0.0f,0.0f};
static GLfloat vertices[] = {	
							0.0f,0.0f,0.0f,
							0.0f,1.0f,0.0f,
							1.0f,0.0f,0.0f,
							
							0.0f,1.0f,0.0f,
							1.0f,1.0f,0.0f,
							1.0f,0.0f,0.0f};

// vertex array object
static unsigned int vertexArrayObjID;
static GLuint sfProgram = -1;

// Initialize common resources, VAO and shader
static void initVAO()
{
	unsigned int vertexBufferObjID;
	
	if (sfProgram != -1) return; // Only do these initializations once!
//	printf("Initializing...\n");
	
		// Load and compile shader
	sfProgram = sfCompileShaders(vert, frag);
	glUseProgram(sfProgram);

	glUniform1i(glGetUniformLocation(sfProgram, "tex"), 0);

	// Allocate and activate Vertex Array Object
	glGenVertexArrays(1, &vertexArrayObjID);
	glBindVertexArray(vertexArrayObjID);
	// Allocate Vertex Buffer Objects
	glGenBuffers(1, &vertexBufferObjID);

	// VBO for vertex data
	glBindBuffer(GL_ARRAY_BUFFER, vertexBufferObjID);
	glBufferData(GL_ARRAY_BUFFER, 18*sizeof(GLfloat), vertices, GL_STATIC_DRAW);
	glVertexAttribPointer(glGetAttribLocation(sfProgram, "inPosition"), 3, GL_FLOAT, GL_FALSE, 0, 0); 
	glEnableVertexAttribArray(glGetAttribLocation(sfProgram, "inPosition"));

	glUniform1i(glGetUniformLocation(sfProgram, "tex"), 0); // Texture unit 0	
}



static void charToTexture(char *indata, int theChar, char *data)
{
	int row = (theChar-32) / 16;
	int col = theChar & 15;
	int startpos = (128 * row*13 + col*8)*4;
	int i, pos, rowchar, bit;
	for (i = 0; i < 13; i++)
	{
		pos = startpos + 128 * (12-i) * 4;
		rowchar = indata[i];
		for (bit = 128; bit != 0; bit = bit >> 1)
		{
//			printf("char %d row %d bit %d\n", theChar, i, bit);
			if ((rowchar & bit) == 0)
			{
				data[pos++] = 0;
				data[pos++] = 0;
				data[pos++] = 0;
				data[pos++] = 0;
			}
			else
			{
				data[pos++] = 255;
				data[pos++] = 255;
				data[pos++] = 255;
				data[pos++] = 255;
			}
		}
	} 
}

//static GLuint fontTexture;

static void fontToTexture()
{
	GLuint i, j, tex, fontTexture;
	glGetIntegerv(GL_TEXTURE_BINDING_2D, &tex); // Save current
	char *data = malloc(128*128*4); // 128x128 pixels, 4 bytes each
	// Why is GL_INTENSITY not available?
	
	// Upper case
	for (i = 0, j = 'A'; i < 26; i++, j++)
		charToTexture(letters[i], j, data);
	// Lower case
	for (i = 0,j = 'a'; i < 26; i++,j++)
		charToTexture(lowletters[i], j, data);
	// Numbers and some more
	for (i = 0,j = '0'; i < 16; i++,j++)
		charToTexture(numletters[i], j, data);
	// Space and some more
	for (i = 0,j = ' '; i < 16; i++,j++)
		charToTexture(specialletters[i], j, data);

	sfLoadExternalFont(data, 8, 13, 128, 128, 2);
/*	
	// Load to texture
	glGenTextures(1, &fontTexture);			// Generate OpenGL texture IDs
	glBindTexture(GL_TEXTURE_2D, fontTexture);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);	// Not filtered
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);	// Not filtered
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 128, 128, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
	
	// Save to font structure! (Multiple font support.)
	allocFont();
	fonts[gCurFont].characterHeight = 13;
	fonts[gCurFont].characterWidth = 8;
	fonts[gCurFont].texHeight = 128;
	fonts[gCurFont].texWidth = 128;
	fonts[gCurFont].extraSpace = 2;
	fonts[gCurFont].textureID = fontTexture;
	free(data);
*/
	glBindTexture(GL_TEXTURE_2D, tex); // Restore
}

GLuint sfLoadExternalFont(char *data, float charWidth, float charHeight, int imageWidth, int imageHeight, int extraSpace)
{
	GLuint i, j, tex, fontTexture;
	GLuint saveprogram;

	glGetIntegerv(GL_TEXTURE_BINDING_2D, &tex); // Save current
	glGetIntegerv(GL_CURRENT_PROGRAM, &saveprogram);
	
	initVAO(); // Init if needed
	
	// Load to texture
	glGenTextures(1, &fontTexture);			// Generate OpenGL texture IDs
	glBindTexture(GL_TEXTURE_2D, fontTexture);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);	// Not filtered
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);	// Not filtered
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, imageWidth, imageHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
	
	// Save to font structure! (Multiple font support.)
	allocFont();
	fonts[gCurFont].characterHeight = charHeight;
	fonts[gCurFont].characterWidth = charWidth;
	fonts[gCurFont].texHeight = imageHeight;
	fonts[gCurFont].texWidth = imageWidth;
	fonts[gCurFont].extraSpace = extraSpace;
	fonts[gCurFont].textureID = fontTexture;
	fonts[gCurFont].fontColorRed = 1;
	fonts[gCurFont].fontColorGreen = 1;
	fonts[gCurFont].fontColorBlue = 1;

	glBindTexture(GL_TEXTURE_2D, tex); // Restore
	glUseProgram(saveprogram);
	return gCurFont;
}

// Initialize the inline font
GLuint sfMakeRasterFont(void)
{
	GLuint tex;
	GLuint saveprogram;
	
	glGetIntegerv(GL_TEXTURE_BINDING_2D, &tex);
	glGetIntegerv(GL_CURRENT_PROGRAM, &saveprogram);
	
	initVAO();

	fontToTexture();
	
	glBindTexture(GL_TEXTURE_2D, tex);
	glUseProgram(saveprogram);
	return gCurFont;
}

static void drawChar(int x, int y, char c)
{
	// uniforms that vary for each character
	glUniform1i(glGetUniformLocation(sfProgram, "x"), x);
	glUniform1i(glGetUniformLocation(sfProgram, "y"), y);
	glUniform1i(glGetUniformLocation(sfProgram, "c"), c-32);
	
	glDrawArrays(GL_TRIANGLES, 0, 6);	// draw object
}

// Note that negative coordinates are allowed
// and refer to the left or bottom!
void sfDrawString(int h, int v, char *s)
{
	int off;
	GLuint tex, activeTxtUnit;
	GLuint saveprogram;
	
//	glPushAttrib? I query individual values instead.
	
	// Get some current settings to restore them later
	char saveZ = glIsEnabled(GL_DEPTH_TEST);
	char saveCull = glIsEnabled(GL_CULL_FACE);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_CULL_FACE);
	
	glGetIntegerv(GL_ACTIVE_TEXTURE, &activeTxtUnit);
	glActiveTexture(GL_TEXTURE0);
	glGetIntegerv(GL_TEXTURE_BINDING_2D, &tex);
	glBindTexture(GL_TEXTURE_2D, fonts[gCurFont].textureID);
	// I also would like to get and restore the current shader program:
	glGetIntegerv(GL_CURRENT_PROGRAM, &saveprogram);
	
	if (h < 0)
		h = gRasterH + h - strlen(s)*fonts[gCurFont].characterWidth;
	if (v < 0)
		v = gRasterV + v; // * 13;

	glUseProgram(sfProgram);
	glBindVertexArray(vertexArrayObjID);	// Select VAO
	// Uniforms that are the same over the whole string
	glUniform1i(glGetUniformLocation(sfProgram, "screenSizeX"), gRasterH);
	glUniform1i(glGetUniformLocation(sfProgram, "screenSizeY"), gRasterV);
	glUniform1f(glGetUniformLocation(sfProgram, "charWidth"), fonts[gCurFont].characterWidth);
	glUniform1f(glGetUniformLocation(sfProgram, "charHeight"), fonts[gCurFont].characterHeight);
	glUniform1i(glGetUniformLocation(sfProgram, "texWidth"), fonts[gCurFont].texWidth);
	glUniform1i(glGetUniformLocation(sfProgram, "texHeight"), fonts[gCurFont].texHeight);
	glUniform1f(glGetUniformLocation(sfProgram, "red"), fonts[gCurFont].fontColorRed);
	glUniform1f(glGetUniformLocation(sfProgram, "green"), fonts[gCurFont].fontColorGreen);
	glUniform1f(glGetUniformLocation(sfProgram, "blue"), fonts[gCurFont].fontColorBlue);
	
	for (;*s != 0;s++)
	{
		drawChar(h, v-fonts[gCurFont].characterHeight, *s); // -10 to get to the proper height
		h += fonts[gCurFont].characterWidth + fonts[gCurFont].extraSpace;
	}
	glBindTexture(GL_TEXTURE_2D, tex);
	glActiveTexture(activeTxtUnit); // or should this be GL_TEXTURE0 + activeTxtUnit? Needs testing!
	glUseProgram(saveprogram);
	if (saveZ) glEnable(GL_DEPTH_TEST);
	if (saveCull) glEnable(GL_CULL_FACE);

//	glPopAttrib ();
}

void sfSetFont(GLuint font)
{
	gCurFont = font;
}

// Sets a color that will be multiplied with the pixel value. Most useful for setting a color on a WHITE font.
// The color is applied to the current font, othr fonts are unaffected.
void sfSetFontColor(GLfloat red, GLfloat green, GLfloat blue)
{
	fonts[gCurFont].fontColorRed = red;
	fonts[gCurFont].fontColorGreen = green;
	fonts[gCurFont].fontColorBlue = blue;
}
